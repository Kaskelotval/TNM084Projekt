<!doctype html>
<html>
	<head>
		<title>learningthree.js boiler plate for three.js</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		
			
		<script src="vendor/three.js/Three.js"></script>
		<script src="vendor/three.js/Detector.js"></script>
		<!-- https://github.com/mrdoob/stats.js -->
		<script src="vendor/three.js/Stats.js"></script>

		<script src="vendor/threex/THREEx.screenshot.js"></script>
		<script src="vendor/threex/THREEx.FullScreen.js"></script>
		<script src="vendor/threex/THREEx.WindowResize.js"></script>
		<script src="vendor/three.js/TrackballControls.js"></script>
		
		<link  href="css/main.css" rel="stylesheet"/>
	</head>
<body>
	<!-- three.js container -->
    	<div id="container"></div>
	<!-- info on screen display -->
	<div id="info">
		<div class="top">
			<a href="http://learningthreejs.com/blog/2011/12/20/boilerplate-for-three-js/" target="_blank">LearningThree.js</a>
			boiler plate for
			<a href="https://github.com/mrdoob/three.js/" target="_blank">three.js</a>
		</div>
		<div class="bottom" id="inlineDoc" >
			- <i>p</i> for screenshot
		</div> 
	</div> 

  <div id="container"></div>
    <script src="js/three.min.js"></script>
        <script src="shaders/vertex.js"></script>
        <script src="shaders/fragment.js"></script>
        <script src="shaders/seaVertex.js"></script>
        <script src="shaders/seaFragment.js"></script>
        <script src="shaders/landVertex.js"></script>
        <script src="shaders/landFragment.js"></script>
    <script>
        var container;
        var camera, scene, renderer, cameraControls;
        var uniforms, light1, light2, sphere;
        var landMeshRef, seaMeshRef;
        var date = new Date();   
        var disp = 2;     

        init();
        animate();

        function init() {
          	
          	renderer = new THREE.WebGLRenderer({alpha: true});
            
			renderer.setSize( window.innerWidth, window.innerHeight );
            container = document.getElementById( 'container' );

           	scene = new THREE.Scene();
			camera	= new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 10000 );
			camera.position.set(0, 0, 5);
			scene.add(camera);
			cameraControls	= new THREE.TrackballControls( camera )
			// transparently support window resize


			//Lights
			// Create light
			light1 = new THREE.PointLight(0xffffff, 1.0);
			// We want it to be very close to our character
			var lightBall = new THREE.Mesh( new THREE.SphereGeometry( 0.3, 16, 16 ), new THREE.MeshBasicMaterial( { color: 0x0000FF } ) );
			light1.position.set(0.0,0.0,-1.0);
			light1.add(lightBall);
			scene.add(light1);

			light2 = new THREE.PointLight(0xffffff, 1.0);

			var lightBall = new THREE.Mesh( new THREE.SphereGeometry( 0.3, 16, 16 ), new THREE.MeshBasicMaterial( { color: 0xFF0000 } ) );
			light2.position.set(3.0,0.0,0.0);			
			light2.add(lightBall);
			scene.add(light2);

			//sea
            suniforms = 	{
	                u_time: { type: "f", value: 1.0 },
	                u_resolution: { type: "v2", value: new THREE.Vector2() },
	                u_mouse: { type: "v2", value: new THREE.Vector2() },
	                u_light1Pos: { type: "v3", value: light1.position},
	                u_light1Col: { type: "v3", value: new THREE.Vector3(10,10,10)},
	                u_light2Pos: { type: "v3", value: light2.position},
	                u_light2Col: { type: "v3", value: new THREE.Vector3(1,0,0)}	    
            	};

            var geometry = new THREE.PlaneBufferGeometry( 200, 200, 200 );
            var material = new THREE.ShaderMaterial( {
                uniforms: suniforms,
                vertexShader: seaVertex,
                fragmentShader: seaFragment,
            } );
			var sea = new THREE.Mesh( geometry, material );
            sea.position.z = -4;	            
			scene.add( sea );

			//landscape
			luniforms = {
	                u_time: { type: "f", value: 1.0 },
	                u_resolution: { type: "v2", value: new THREE.Vector2() },
	                u_mouse: { type: "v2", value: new THREE.Vector2() },
	                u_light1Pos: { type: "v3", value: light1.position},
	                u_light1Col: { type: "v3", value: new THREE.Vector3(10,10,10)},
	                u_light2Pos: { type: "v3", value: light2.position},
	                u_light2Col: { type: "v3", value: new THREE.Vector3(0.7,0.7,0.7)}					
			};

            landgeometry = new THREE.PlaneGeometry( 200, 200, 100,100);
            landmaterial = new THREE.ShaderMaterial( {
                uniforms: luniforms,
                vertexShader: landVertex,
                fragmentShader: landFragment,
            } );
			var land = new THREE.Mesh( landgeometry, landmaterial );
			land.rotation.x = Math.PI*3/2;
            land.position.z = -3;	            
			scene.add( land );


            container.appendChild( renderer.domElement );

            onWindowResize();
            window.addEventListener( 'resize', onWindowResize, false );

            document.onmousemove = function(e){
              suniforms.u_mouse.value.x = e.pageX
              suniforms.u_mouse.value.y = e.pageY
            }
        }

        function onWindowResize( event ) {
        	camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.render(scene,camera);
            suniforms.u_resolution.value.x = window.innerWidth;
            suniforms.u_resolution.value.y = window.innerHeight;
        }

        function animate() {	        	
            requestAnimationFrame( animate );
            render();
        }

        function render() {
        	//Move lights
        	light1.position.x = Math.sin(2*suniforms.u_time.value)*(disp);
        	light1.position.y = Math.cos(2*suniforms.u_time.value)*(disp);
        	light2.position.x = Math.cos(suniforms.u_time.value)*disp;
        	light2.position.z = Math.sin(suniforms.u_time.value)*disp;
			cameraControls.update();
            suniforms.u_time.value += 0.05;
            luniforms.u_time.value += 0.05;

            renderer.render( scene, camera );
        }
    </script>
</body>
</html>
